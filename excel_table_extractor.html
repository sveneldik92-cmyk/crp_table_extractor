<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Excel Graphical Table Extractor</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f7f8fb;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --danger: #dc2626;
      --success: #16a34a;
      --border: #e5e7eb;
      --shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      --detail-scale: 1;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    header {
      background: linear-gradient(120deg, #1d4ed8, #3b82f6);
      color: #fff;
      padding: 28px 20px;
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.6rem, 2vw, 2.2rem);
    }

    header p {
      margin: 0;
      max-width: 720px;
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.95rem;
    }

    main {
      display: grid;
      grid-template-columns: minmax(280px, 320px) 1fr;
      gap: 20px;
      padding: 20px;
    }

    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }

    .section-title {
      margin: 0 0 12px;
      font-size: 1rem;
      font-weight: 600;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    .button.secondary {
      background: var(--accent-soft);
      color: var(--accent);
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 15px rgba(37, 99, 235, 0.2);
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    select,
    input[type="file"],
    input[type="text"] {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #fff;
      font-size: 0.9rem;
    }

    .accordion {
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow: hidden;
      margin-bottom: 12px;
      background: #fff;
    }

    details {
      border-bottom: 1px solid var(--border);
    }

    details:last-child {
      border-bottom: none;
    }

    summary {
      list-style: none;
      cursor: pointer;
      padding: 12px 16px;
      font-weight: 600;
      position: relative;
    }

    summary::-webkit-details-marker {
      display: none;
    }

    summary::after {
      content: "â–¾";
      position: absolute;
      right: 16px;
      transform: rotate(0deg);
      transition: transform 0.2s ease;
    }

    details[open] summary::after {
      transform: rotate(180deg);
    }

    details .content {
      padding: 0 16px 16px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .report-grid {
      display: grid;
      gap: 16px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    .stat-card {
      padding: 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fff;
    }

    .stat-card strong {
      display: block;
      font-size: 1.2rem;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: var(--accent-soft);
      color: var(--accent);
    }

    .table-preview {
      overflow: auto;
      max-height: 420px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fff;
    }

    .table-preview.zoomable th,
    .table-preview.zoomable td {
      padding: calc(6px * var(--detail-scale)) calc(8px * var(--detail-scale));
      font-size: calc(0.85rem * var(--detail-scale));
    }

    .detail-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }

    .detail-controls span {
      font-size: 0.85rem;
      color: var(--muted);
    }

    table {
      border-collapse: collapse;
      min-width: 100%;
      font-size: 0.85rem;
    }

    th,
    td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #f1f5f9;
      font-weight: 600;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      background: #fff;
      box-shadow: var(--shadow);
    }

    .card h4 {
      margin: 0 0 8px;
    }

    .muted {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
    }

    .pill.success {
      color: var(--success);
      border-color: rgba(22, 163, 74, 0.4);
      background: rgba(22, 163, 74, 0.08);
    }

    .pill.warning {
      color: var(--danger);
      border-color: rgba(220, 38, 38, 0.3);
      background: rgba(220, 38, 38, 0.08);
    }

    .stack {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .two-col {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .progress {
      height: 8px;
      background: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      background: var(--accent);
      width: 0;
      transition: width 0.3s ease;
    }

    .footer-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .linkish {
      color: var(--accent);
      text-decoration: underline;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .small {
      font-size: 0.8rem;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .tab-button {
      border: 1px solid var(--border);
      background: #fff;
      color: var(--muted);
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
    }

    .tab-button.active {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    .facts-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
    }

    .facts-table {
      max-height: 520px;
    }

    .facts-table thead th {
      position: sticky;
      top: 0;
      background: #f1f5f9;
      z-index: 1;
    }

    .facts-table thead tr.filter-row th {
      top: 32px;
      background: #fff;
    }

    .facts-table select {
      width: 100%;
      font-size: 0.75rem;
      padding: 4px 6px;
    }

    .facts-table table {
      width: 100%;
      table-layout: fixed;
    }

    .facts-table th,
    .facts-table td {
      white-space: normal;
      word-break: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .facts-table th {
      position: relative;
    }

    .resize-handle {
      position: absolute;
      top: 0;
      right: 0;
      width: 6px;
      height: 100%;
      cursor: col-resize;
      user-select: none;
    }

    .resize-handle::after {
      content: "";
      position: absolute;
      top: 20%;
      right: 2px;
      width: 2px;
      height: 60%;
      background: #cbd5f5;
      border-radius: 999px;
    }

    .pager {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .button.small {
      padding: 6px 12px;
      font-size: 0.75rem;
    }

    .count-badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      background: var(--accent-soft);
      color: var(--accent);
    }

    .count-badge.alert {
      background: var(--danger);
      color: #fff;
    }

    .pivot-summary-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .pivot-tree {
      list-style: disc;
      margin: 0;
      padding-left: 20px;
      color: var(--muted);
    }

    .pivot-tree li {
      margin: 6px 0;
    }

    .pivot-tree .pivot-label {
      color: var(--text);
      font-weight: 600;
    }

    .pivot-tree .pivot-subtle {
      font-weight: 500;
    }
  </style>
</head>
<body>
  <header>
    <h1>Excel Graphical Table Extractor</h1>
    <p>Upload a spreadsheet, detect merged-cell graphical tables, and export structured data with full extraction reporting. Runs entirely in your browser.</p>
  </header>

  <main>
    <section>
      <div class="accordion">
        <details open>
          <summary>How extraction works</summary>
          <div class="content">
            This tool scans each sheet for the Key/Module header row, then resolves merged cells so header labels and machine names are read from their top-left anchors. It identifies header bands, time columns, and data rows, then builds table records and flattened facts.
          </div>
        </details>
        <details>
          <summary>Known limitations</summary>
          <div class="content">
            Formatting-only borders are ignored. Detection relies on text signatures (Key/Module and metadata labels). Merged header labels are resolved via merge anchors, so empty-looking cells still map to their visible text.
          </div>
        </details>
      </div>

      <div class="panel controls">
        <div class="input-group">
          <label for="fileInput">Excel file (.xlsx, .xlsm)</label>
          <input id="fileInput" type="file" accept=".xlsx,.xlsm,application/vnd.ms-excel.sheet.macroEnabled.12" />
        </div>
        <button class="button" id="runBtn" disabled>Run extraction</button>
        <div class="progress"><span id="progressBar"></span></div>
        <div class="footer-actions">
          <button class="button secondary" id="exportCsvBtn" disabled>Export Facts Workbook</button>
          <button class="button secondary" id="exportJsonBtn" disabled>Export JSON</button>
          <button class="button secondary" id="exportLogBtn" disabled>Export Log</button>
          <button class="button secondary" id="exportMacroBtn" disabled>Export VBA Macro</button>
        </div>
        <div class="panel" style="box-shadow:none; border:1px dashed var(--border);">
          <h3 class="section-title">Filters</h3>
          <div class="input-group">
            <label for="filterDepartment">Department</label>
            <select id="filterDepartment"></select>
          </div>
          <div class="input-group">
            <label for="filterMachine">Machine</label>
            <select id="filterMachine"></select>
          </div>
          <div class="input-group">
            <label for="filterTimeframe">Timeframe</label>
            <select id="filterTimeframe"></select>
          </div>
          <div class="input-group">
            <label for="filterUnit">Unit</label>
            <select id="filterUnit"></select>
          </div>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="tabs">
        <button class="tab-button active" data-tab="report">Extraction report</button>
        <button class="tab-button" data-tab="facts">Facts table</button>
        <button class="tab-button" data-tab="log">Full log</button>
        <button class="tab-button" data-tab="guide">Feature guide</button>
      </div>

      <div id="tab-report" class="tab-panel active">
        <div class="report-grid">
          <div>
            <h3 class="section-title">Extraction Summary</h3>
            <div id="summaryStats" class="stat-grid"></div>
          </div>

          <div>
            <h3 class="section-title">Expected-shape sanity check</h3>
            <p class="muted" id="expectedShape"></p>
          </div>

          <div>
            <h3 class="section-title">Pivot summary</h3>
            <div id="pivotSummary"></div>
          </div>

          <div>
            <h3 class="section-title">Target tables</h3>
            <div id="tableCards" class="stack"></div>
          </div>

          <div>
            <h3 class="section-title">Non-target tables (quarantine)</h3>
            <div id="quarantineCards" class="stack"></div>
          </div>

          <div>
            <h3 class="section-title">Detail view</h3>
            <div class="detail-controls">
              <label for="detailScale" class="small">Zoom</label>
              <input id="detailScale" type="range" min="0.6" max="1.6" step="0.1" value="1" />
              <span id="detailScaleValue">100%</span>
            </div>
            <div id="detailView" class="card"></div>
          </div>
        </div>
      </div>

      <div id="tab-facts" class="tab-panel">
        <div class="facts-controls">
          <div class="input-group" style="min-width: 220px;">
            <label for="factsSearch">Search across all columns</label>
            <input id="factsSearch" type="text" placeholder="Type to filter..." />
          </div>
          <div class="input-group" style="min-width: 180px;">
            <label for="factsPageSize">Rows per page</label>
            <select id="factsPageSize">
              <option value="100">100</option>
              <option value="250" selected>250</option>
              <option value="500">500</option>
              <option value="1000">1000</option>
            </select>
          </div>
          <button class="button secondary" id="clearFactsFilters">Clear filters</button>
          <div class="pager">
            <button class="button secondary small" id="factsPrev">Prev</button>
            <span class="muted small" id="factsPageStatus"></span>
            <button class="button secondary small" id="factsNext">Next</button>
          </div>
          <span class="muted" id="factsRowCount"></span>
        </div>
        <div id="factsTableContainer" class="table-preview facts-table"></div>
      </div>

      <div id="tab-log" class="tab-panel">
        <h3 class="section-title">Extraction log</h3>
        <p class="muted" id="logSummary"></p>
        <pre id="logOutput" class="card" style="max-height: 520px; overflow: auto; white-space: pre-wrap;"></pre>
      </div>

      <div id="tab-guide" class="tab-panel">
        <h3 class="section-title">Feature guide</h3>
        <div class="card">
          <h4>What this extractor focuses on</h4>
          <p class="muted">The extractor looks for tables that are visually structured with a Key/Module header row, metadata labels above, and time columns to the right. It treats merged cells as a single label so the visible text is always captured.</p>
          <h4>How to read the extraction report</h4>
          <ul class="muted">
            <li><strong>Extraction summary</strong> shows how many tables were detected and how many were quarantined.</li>
            <li><strong>Expected-shape sanity check</strong> compares what was found to the expected shape of the workbook.</li>
            <li><strong>Pivot summary</strong> gives a quick count of tables per department, machine, timeframe, and unit.</li>
            <li><strong>Target tables</strong> lists each extracted table with a confidence score and flags.</li>
            <li><strong>Non-target tables</strong> highlights candidates that were intentionally skipped.</li>
          </ul>
          <h4>Facts table tips</h4>
          <ul class="muted">
            <li>Use the column filters and search to narrow down the data quickly.</li>
            <li>Resize columns by dragging the handle on a header.</li>
            <li>Sort by clicking any column header, including time columns which sort chronologically.</li>
          </ul>
          <h4>Exporting data</h4>
          <ul class="muted">
            <li><strong>Facts workbook</strong> exports the flattened, analysis-ready facts.</li>
            <li><strong>JSON</strong> preserves the table structure and summary.</li>
            <li><strong>Log</strong> captures any warnings or detection notes for review.</li>
            <li><strong>VBA macro</strong> writes an Excel module that recreates the tables as Power Query connections.</li>
          </ul>
        </div>
      </div>
    </section>
  </main>

  <script>
    const state = {
      workbook: null,
      tableRecords: [],
      facts: [],
      nonTargetTables: [],
      extractionLog: [],
      summary: null,
      filters: {
        department: 'All',
        machine: 'All',
        timeframe: 'All',
        unit: 'All'
      },
      detailScale: 1,
      factsSearch: '',
      factsColumnFilters: {},
      factsColumnWidths: {},
      factsSort: {
        key: null,
        direction: 'asc'
      },
      factsPagination: {
        page: 1,
        perPage: 250
      }
    };

    const fileInput = document.getElementById('fileInput');
    const runBtn = document.getElementById('runBtn');
    const exportCsvBtn = document.getElementById('exportCsvBtn');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const exportLogBtn = document.getElementById('exportLogBtn');
    const exportMacroBtn = document.getElementById('exportMacroBtn');
    const progressBar = document.getElementById('progressBar');
    const summaryStats = document.getElementById('summaryStats');
    const tableCards = document.getElementById('tableCards');
    const quarantineCards = document.getElementById('quarantineCards');
    const detailView = document.getElementById('detailView');
    const expectedShape = document.getElementById('expectedShape');
    const detailScale = document.getElementById('detailScale');
    const detailScaleValue = document.getElementById('detailScaleValue');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabReport = document.getElementById('tab-report');
    const tabFacts = document.getElementById('tab-facts');
    const tabLog = document.getElementById('tab-log');
    const tabGuide = document.getElementById('tab-guide');
    const factsSearch = document.getElementById('factsSearch');
    const factsPageSize = document.getElementById('factsPageSize');
    const clearFactsFilters = document.getElementById('clearFactsFilters');
    const factsRowCount = document.getElementById('factsRowCount');
    const factsTableContainer = document.getElementById('factsTableContainer');
    const factsPrev = document.getElementById('factsPrev');
    const factsNext = document.getElementById('factsNext');
    const factsPageStatus = document.getElementById('factsPageStatus');
    const logOutput = document.getElementById('logOutput');
    const logSummary = document.getElementById('logSummary');
    const pivotSummary = document.getElementById('pivotSummary');

    const filterDepartment = document.getElementById('filterDepartment');
    const filterMachine = document.getElementById('filterMachine');
    const filterTimeframe = document.getElementById('filterTimeframe');
    const filterUnit = document.getElementById('filterUnit');

    const EXPECTED = {
      departments: 3,
      machines: 3,
      timeframes: 3,
      units: 4
    };

    fileInput.addEventListener('change', () => {
      runBtn.disabled = !fileInput.files.length;
    });

    detailScale.addEventListener('input', (event) => {
      const scale = Number(event.target.value);
      state.detailScale = scale;
      document.documentElement.style.setProperty('--detail-scale', scale);
      detailScaleValue.textContent = `${Math.round(scale * 100)}%`;
    });

    runBtn.addEventListener('click', async () => {
      if (!fileInput.files.length) return;
      resetState();
      const file = fileInput.files[0];
      logEvent('info', `Loaded file "${file.name}" (${(file.size / 1024).toFixed(1)} KB).`);
      const data = await file.arrayBuffer();
      state.workbook = XLSX.read(data, { type: 'array', cellDates: true });
      await runExtraction();
      renderAll();
      exportCsvBtn.disabled = state.facts.length === 0;
      exportJsonBtn.disabled = state.tableRecords.length === 0;
      exportLogBtn.disabled = state.extractionLog.length === 0;
      exportMacroBtn.disabled = state.tableRecords.length === 0;
    });

    filterDepartment.addEventListener('change', () => {
      state.filters.department = filterDepartment.value;
      state.factsPagination.page = 1;
      renderTables();
      renderFactsTable();
    });
    filterMachine.addEventListener('change', () => {
      state.filters.machine = filterMachine.value;
      state.factsPagination.page = 1;
      renderTables();
      renderFactsTable();
    });
    filterTimeframe.addEventListener('change', () => {
      state.filters.timeframe = filterTimeframe.value;
      state.factsPagination.page = 1;
      renderTables();
      renderFactsTable();
    });
    filterUnit.addEventListener('change', () => {
      state.filters.unit = filterUnit.value;
      state.factsPagination.page = 1;
      renderTables();
      renderFactsTable();
    });

    tabButtons.forEach((button) => {
      button.addEventListener('click', () => {
        tabButtons.forEach((btn) => btn.classList.remove('active'));
        button.classList.add('active');
        const tab = button.dataset.tab;
        tabReport.classList.toggle('active', tab === 'report');
        tabFacts.classList.toggle('active', tab === 'facts');
        tabLog.classList.toggle('active', tab === 'log');
        tabGuide.classList.toggle('active', tab === 'guide');
        if (tab === 'facts') {
          renderFactsTable();
        }
        if (tab === 'log') {
          renderLog();
        }
      });
    });

    factsSearch.addEventListener('input', (event) => {
      state.factsSearch = event.target.value || '';
      state.factsPagination.page = 1;
      renderFactsTable();
    });

    factsPageSize.addEventListener('change', (event) => {
      state.factsPagination.perPage = Number(event.target.value) || 250;
      state.factsPagination.page = 1;
      renderFactsTable();
    });

    clearFactsFilters.addEventListener('click', () => {
      state.factsSearch = '';
      state.factsColumnFilters = {};
      state.factsSort = { key: null, direction: 'asc' };
      state.factsPagination.page = 1;
      factsSearch.value = '';
      renderFactsTable();
    });

    factsPrev.addEventListener('click', () => {
      if (state.factsPagination.page > 1) {
        state.factsPagination.page -= 1;
        renderFactsTable();
      }
    });

    factsNext.addEventListener('click', () => {
      state.factsPagination.page += 1;
      renderFactsTable();
    });

    exportCsvBtn.addEventListener('click', () => {
      exportFactsWorkbook();
    });

    exportJsonBtn.addEventListener('click', () => {
      const payload = {
        summary: state.summary,
        tableRecords: state.tableRecords,
        facts: state.facts
      };
      downloadFile(JSON.stringify(payload, null, 2), 'extraction.json', 'application/json');
    });

    exportLogBtn.addEventListener('click', () => {
      downloadFile(state.extractionLog.join('\n'), 'extraction_log.txt', 'text/plain');
    });

    exportMacroBtn.addEventListener('click', () => {
      const macro = buildMacroModule(state.tableRecords);
      downloadFile(macro, 'extraction_power_query.bas', 'text/plain');
    });

    function resetState() {
      state.tableRecords = [];
      state.facts = [];
      state.nonTargetTables = [];
      state.extractionLog = [];
      state.summary = null;
      state.detailScale = 1;
      state.factsSearch = '';
      state.factsColumnFilters = {};
      state.factsColumnWidths = {};
      state.factsSort = { key: null, direction: 'asc' };
      state.factsPagination = { page: 1, perPage: 250 };
      tableCards.innerHTML = '';
      quarantineCards.innerHTML = '';
      detailView.innerHTML = '<p class="muted">Select a table to see details.</p>';
      summaryStats.innerHTML = '';
      progressBar.style.width = '0%';
      detailScale.value = '1';
      detailScaleValue.textContent = '100%';
      document.documentElement.style.setProperty('--detail-scale', '1');
      factsSearch.value = '';
      factsPageSize.value = '250';
      factsTableContainer.innerHTML = '';
      factsRowCount.textContent = '';
      logOutput.textContent = '';
      logSummary.textContent = '';
    }

    function logEvent(level, message, context = null) {
      const timestamp = new Date().toISOString();
      const levelTag = `[${level.toUpperCase()}]`;
      const contextText = context ? ` ${JSON.stringify(context)}` : '';
      state.extractionLog.push(`${timestamp} ${levelTag} ${message}${contextText}`);
    }

    async function runExtraction() {
      const sheetNames = state.workbook.SheetNames;
      const totalSheets = sheetNames.length;
      logEvent('info', `Starting extraction across ${totalSheets} sheet${totalSheets === 1 ? '' : 's'}.`);
      for (let index = 0; index < sheetNames.length; index += 1) {
        const sheetName = sheetNames[index];
        const ws = state.workbook.Sheets[sheetName];
        const grid = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: null });
        const mergeInfo = buildMergeLookup(ws['!merges'] || []);
        logEvent('info', `Scanning sheet "${sheetName}".`);
        extractTablesFromSheet({ sheetName, ws, grid, mergeInfo });
        progressBar.style.width = `${Math.round(((index + 1) / totalSheets) * 100)}%`;
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
      detectOverlappingTables();
      buildFacts();
      computeSummary();
      logEvent('info', `Extraction complete. ${state.tableRecords.length} target tables, ${state.nonTargetTables.length} quarantined.`);
    }

    function detectOverlappingTables() {
      const overlapsById = new Map();
      const bySheet = new Map();
      state.tableRecords.forEach((record) => {
        const list = bySheet.get(record.sheetName) || [];
        list.push(record);
        bySheet.set(record.sheetName, list);
        overlapsById.set(record.id, []);
      });

      for (const [sheetName, records] of bySheet.entries()) {
        for (let i = 0; i < records.length; i += 1) {
          const recordA = records[i];
          for (let j = i + 1; j < records.length; j += 1) {
            const recordB = records[j];
            if (rangesOverlap(recordA.tableRange, recordB.tableRange)) {
              overlapsById.get(recordA.id).push(recordB.id);
              overlapsById.get(recordB.id).push(recordA.id);
              logEvent('error', `Overlapping tables detected on "${sheetName}": ${recordA.id} overlaps ${recordB.id}.`, {
                sheetName,
                tableA: recordA.id,
                tableB: recordB.id,
                rangeA: recordA.tableRange,
                rangeB: recordB.tableRange
              });
            }
          }
        }
      }

      state.tableRecords.forEach((record) => {
        record.overlapsWith = overlapsById.get(record.id) || [];
      });
    }

    function rangesOverlap(a, b) {
      return a.r0 <= b.r1 && a.r1 >= b.r0 && a.c0 <= b.c1 && a.c1 >= b.c0;
    }

    function buildMergeLookup(merges) {
      const anchorToRange = new Map();
      const cellToAnchor = new Map();
      merges.forEach((range) => {
        const key = `${range.s.r},${range.s.c}`;
        anchorToRange.set(key, range);
        for (let r = range.s.r; r <= range.e.r; r += 1) {
          for (let c = range.s.c; c <= range.e.c; c += 1) {
            cellToAnchor.set(`${r},${c}`, { ar: range.s.r, ac: range.s.c });
          }
        }
      });
      return {
        anchorToRange,
        getMergeAnchor(r, c) {
          return cellToAnchor.get(`${r},${c}`) || null;
        },
        isMergeAnchor(r, c) {
          const anchor = cellToAnchor.get(`${r},${c}`);
          return anchor ? anchor.ar === r && anchor.ac === c : false;
        }
      };
    }

    function normalizeValue(value) {
      if (value == null) return null;
      if (typeof value === 'string') {
        const trimmed = value.trim();
        return trimmed === '' ? null : trimmed;
      }
      if (typeof value === 'number') return value;
      if (value instanceof Date) return value.toISOString().split('T')[0];
      return String(value).trim() || null;
    }

    function isEmptyValue(value) {
      return value == null || (typeof value === 'string' && value.trim() === '');
    }

    function normalizeHeaderText(value) {
      return String(value ?? '').trim().toLowerCase();
    }

    function getVisibleValue(ws, grid, mergeInfo, r, c) {
      const anchor = mergeInfo.getMergeAnchor(r, c);
      if (anchor) {
        return normalizeValue(grid[anchor.ar]?.[anchor.ac]);
      }
      return normalizeValue(grid[r]?.[c]);
    }

    function normalizeHeaderTime(value) {
      if (value == null) return null;
      if (typeof value === 'number' && value > 25000 && value < 60000) {
        const date = XLSX.SSF.parse_date_code(value);
        if (date) {
          const iso = new Date(Date.UTC(date.y, date.m - 1, date.d)).toISOString();
          return iso.split('T')[0];
        }
      }
      return String(value).trim();
    }

    function parseTimeLabel(value) {
      if (value == null) return null;
      const raw = String(value).trim();
      if (!raw) return null;
      const match = raw.match(/^(\d{4})\s*[.\-]?\s*Q([1-4])$/i);
      if (match) {
        return {
          type: 'year-quarter',
          year: Number(match[1]),
          quarter: Number(match[2]),
          raw
        };
      }
      const yearOnly = raw.match(/^(\d{4})$/);
      if (yearOnly) {
        return {
          type: 'year',
          year: Number(yearOnly[1]),
          quarter: 0,
          raw
        };
      }
      const dateValue = Date.parse(raw);
      if (!Number.isNaN(dateValue)) {
        const date = new Date(dateValue);
        return {
          type: 'date',
          year: date.getUTCFullYear(),
          quarter: Math.floor(date.getUTCMonth() / 3) + 1,
          raw,
          timestamp: dateValue
        };
      }
      return { type: 'text', raw };
    }

    function compareTimeLabels(a, b) {
      const parsedA = parseTimeLabel(a);
      const parsedB = parseTimeLabel(b);
      if (!parsedA && !parsedB) return 0;
      if (!parsedA) return 1;
      if (!parsedB) return -1;
      const typeOrder = (type) => {
        switch (type) {
          case 'year':
          case 'year-quarter':
            return 0;
          case 'date':
            return 1;
          default:
            return 2;
        }
      };
      const typeDiff = typeOrder(parsedA.type) - typeOrder(parsedB.type);
      if (typeDiff !== 0) return typeDiff;
      if (parsedA.type === 'date' && parsedB.type === 'date') {
        if (parsedA.timestamp !== parsedB.timestamp) return parsedA.timestamp - parsedB.timestamp;
      }
      if ('year' in parsedA && 'year' in parsedB) {
        if (parsedA.year !== parsedB.year) return parsedA.year - parsedB.year;
        if (parsedA.quarter !== parsedB.quarter) return parsedA.quarter - parsedB.quarter;
      }
      return String(parsedA.raw).localeCompare(String(parsedB.raw));
    }

    function extractTablesFromSheet({ sheetName, ws, grid, mergeInfo }) {
      const department = sheetName;
      const headerCandidates = findHeaderCandidates(ws, grid, mergeInfo);
      headerCandidates.forEach((candidate) => {
        const result = processCandidate({ candidate, sheetName, department, ws, grid, mergeInfo });
        if (result) {
          state.tableRecords.push(result.tableRecord);
        }
      });
    }

    function findHeaderCandidates(ws, grid, mergeInfo) {
      const candidates = [];
      const seen = new Set();
      const addCandidate = (r, c) => {
        const key = `${r},${c}`;
        if (seen.has(key)) return;
        seen.add(key);
        candidates.push({ r, c });
      };
      for (let r = 0; r < grid.length; r += 1) {
        const row = grid[r] || [];
        for (let c = 0; c < row.length; c += 1) {
          const value = getVisibleValue(ws, grid, mergeInfo, r, c);
          const next = getVisibleValue(ws, grid, mergeInfo, r, c + 1);
          const third = getVisibleValue(ws, grid, mergeInfo, r, c + 2);
          if (value && next && /^key$/i.test(String(value)) && /^module$/i.test(String(next)) && !isEmptyValue(third)) {
            addCandidate(r, c);
          }
          if (value && /^key$/i.test(String(value)) && r + 1 < grid.length) {
            const belowModule = getVisibleValue(ws, grid, mergeInfo, r + 1, c + 1);
            const belowThird = getVisibleValue(ws, grid, mergeInfo, r + 1, c + 2);
            if (belowModule && /^module$/i.test(String(belowModule)) && !isEmptyValue(belowThird)) {
              addCandidate(r + 1, c);
            }
          }
        }
      }
      return candidates;
    }

    function processCandidate({ candidate, sheetName, department, ws, grid, mergeInfo }) {
      const rh = candidate.r;
      const tableKeyCol = candidate.c;
      const tableModuleCol = tableKeyCol + 1;
      const timeStartCol = tableKeyCol + 2;
      const headerKey = normalizeHeaderText(getVisibleValue(ws, grid, mergeInfo, rh, tableKeyCol));
      const headerModule = normalizeHeaderText(getVisibleValue(ws, grid, mergeInfo, rh, tableModuleCol));
      const topLeftValue = rh > 0 ? getVisibleValue(ws, grid, mergeInfo, rh - 1, tableKeyCol) : null;
      const headerRowValues = collectTimeHeaders({ ws, grid, mergeInfo, rh, timeStartCol, sheetName, tableKeyCol });
      const timeHeaders = headerRowValues.headers;
      const cEnd = headerRowValues.cEnd;

      const metaResult = extractMetadata({ ws, grid, mergeInfo, rh, tableKeyCol, timeStartCol });
      const unitLabel = metaResult.unitLabel;
      const timeframeLabel = metaResult.timeframeLabel;
      const headerRange = metaResult.headerRange;
      const rMeta = metaResult.rMeta;

      const dataScan = scanDataRows({ ws, grid, mergeInfo, rh, tableKeyCol, tableModuleCol, timeStartCol, cEnd });
      const rEnd = dataScan.rEnd;
      const dataRows = dataScan.dataRows;

      const reasons = [];
      if (!isEmptyValue(topLeftValue)) reasons.push('top-left cell not blank');
      if (headerKey !== 'key' || headerModule !== 'module') reasons.push('missing key/module header row');
      if (!unitLabel || !timeframeLabel) reasons.push('missing metadata labels');
      if (timeHeaders.length < 2) reasons.push('time headers too short');
      if (dataRows.length === 0) reasons.push('no data rows');

      const isTarget = reasons.length === 0;

      const tableRange = { r0: rMeta, c0: tableKeyCol, r1: rEnd, c1: cEnd };
      const machineName = resolveMachineName({ ws, grid, mergeInfo, rh, rMeta, tableKeyCol, rEnd });
      const boundaryScore = checkBoundaryIsolation({ ws, grid, mergeInfo, tableRange });

      if (!isTarget) {
        state.nonTargetTables.push({
          id: `Q-${sheetName}-${rh}-${tableKeyCol}`,
          sheetName,
          department,
          headerRow: rh,
          keyColumn: tableKeyCol,
          tableRange,
          reasons,
          preview: buildPreview({ ws, grid, mergeInfo, r0: rMeta, c0: tableKeyCol, r1: Math.min(rEnd, rMeta + 8), c1: Math.min(cEnd, tableKeyCol + 8) })
        });
        logEvent('warn', `Quarantined table candidate on "${sheetName}" (r${rh}, c${tableKeyCol}).`, {
          reasons
        });
        return null;
      }

      const tableId = `T-${sheetName}-${rh}-${tableKeyCol}`;
      const { rows, totalRow } = parseTableRows({
        ws,
        grid,
        mergeInfo,
        rh,
        rEnd,
        tableKeyCol,
        tableModuleCol,
        timeStartCol,
        timeHeaders,
        cEnd,
        sheetName,
        tableId
      });

      const qualityFlags = [];
      if (!machineName || machineName === 'Unknown machine') qualityFlags.push('Missing machine name');
      if (!boundaryScore.isIsolated) qualityFlags.push('Weak boundary isolation');
      if (totalRow) qualityFlags.push('Total row detected');

      const tableRecord = {
        id: tableId,
        department,
        sheetName,
        machineName: machineName || 'Unknown machine',
        unitLabel,
        timeframeLabel,
        tableRange,
        headerRow: rh,
        headerRange,
        detectedAt: new Date().toISOString(),
        times: timeHeaders.map((header) => header.label),
        rows,
        totalRow,
        qualityFlags
      };

      const logEntry = {
        sheetName,
        candidate: { rh, tableKeyCol },
        status: 'target',
        unitLabel,
        timeframeLabel,
        timeColumns: timeHeaders.length,
        dataRows: rows.length,
        machineName: tableRecord.machineName,
        boundaryScore
      };

      logEvent('info', `Detected target table ${tableId} on "${sheetName}".`, logEntry);
      return { tableRecord, logEntry };
    }

    function collectTimeHeaders({ ws, grid, mergeInfo, rh, timeStartCol, sheetName, tableKeyCol }) {
      const headers = [];
      const headersByLabel = new Map();
      const duplicates = [];
      let cEnd = timeStartCol;
      let emptyStreak = 0;
      let started = false;
      const maxWidth = timeStartCol + 250;
      for (let c = timeStartCol; c <= maxWidth; c += 1) {
        if (!mergeInfo.isMergeAnchor(rh, c) && mergeInfo.getMergeAnchor(rh, c)) {
          continue;
        }
        const value = getVisibleValue(ws, grid, mergeInfo, rh, c);
        if (!isEmptyValue(value)) {
          const normalized = normalizeHeaderTime(value);
          const nextValue = getVisibleValue(ws, grid, mergeInfo, rh, c + 1);
          const isKeyHeader = /^key$/i.test(String(normalized));
          const isModuleHeader = /^module$/i.test(String(normalized));
          const isNextModule = /^module$/i.test(String(nextValue || ''));
          if ((isKeyHeader && isNextModule && started) || (isModuleHeader && started)) {
            break;
          }
          if (isKeyHeader || isModuleHeader) {
            if (!started) continue;
            continue;
          }
          const label = normalized;
          if (headersByLabel.has(label)) {
            const header = headersByLabel.get(label);
            header.extraCols.push(c);
            duplicates.push({ label, col: c, primaryCol: header.col });
          } else {
            const header = { label, col: c, extraCols: [] };
            headersByLabel.set(label, header);
            headers.push(header);
          }
          cEnd = c;
          emptyStreak = 0;
          started = true;
        } else if (started) {
          emptyStreak += 1;
          if (emptyStreak >= 2) break;
        }
      }
      if (duplicates.length) {
        logEvent('error', `Duplicate time header labels detected on "${sheetName}" (row ${rh}).`, {
          tableKeyCol,
          duplicates
        });
      }
      return { headers: headers.filter((header) => header && header.label), cEnd };
    }

    function extractMetadata({ ws, grid, mergeInfo, rh, tableKeyCol, timeStartCol }) {
      const candidates = [rh - 1, rh - 2].filter((r) => r >= 0);
      let unitLabel = null;
      let timeframeLabel = null;
      let rMeta = candidates[0] ?? rh - 1;
      let headerRange = { r0: rMeta, c0: tableKeyCol, r1: rh, c1: timeStartCol + 5 };

      for (const rMetaCandidate of candidates) {
        const scan = scanMetadataRow({ ws, grid, mergeInfo, r: rMetaCandidate, c0: tableKeyCol, c1: timeStartCol + 6 });
        if (scan.unitLabel && scan.timeframeLabel) {
          unitLabel = scan.unitLabel;
          timeframeLabel = scan.timeframeLabel;
          rMeta = rMetaCandidate;
          headerRange = { r0: rMetaCandidate, c0: tableKeyCol, r1: rh, c1: timeStartCol + 6 };
          break;
        }
      }

      if (!unitLabel || !timeframeLabel) {
        const fallback = scanMetadataRow({ ws, grid, mergeInfo, r: rh - 1, c0: tableKeyCol, c1: timeStartCol + 6 });
        unitLabel = unitLabel || fallback.unitLabel;
        timeframeLabel = timeframeLabel || fallback.timeframeLabel;
      }

      return { unitLabel, timeframeLabel, headerRange, rMeta };
    }

    function scanMetadataRow({ ws, grid, mergeInfo, r, c0, c1 }) {
      let unitLabel = null;
      let timeframeLabel = null;
      for (let c = c0; c <= c1; c += 1) {
        const value = getVisibleValue(ws, grid, mergeInfo, r, c);
        if (!isEmptyValue(value)) {
          if (!unitLabel) {
            unitLabel = String(value);
          } else if (!timeframeLabel) {
            timeframeLabel = String(value);
            break;
          }
        }
      }
      if (!timeframeLabel && r + 1 < grid.length) {
        for (let c = c0; c <= c1; c += 1) {
          const value = getVisibleValue(ws, grid, mergeInfo, r + 1, c);
          if (!isEmptyValue(value)) {
            if (!unitLabel) {
              unitLabel = String(value);
            } else if (!timeframeLabel) {
              timeframeLabel = String(value);
              break;
            }
          }
        }
      }
      return { unitLabel, timeframeLabel };
    }

    function scanDataRows({ ws, grid, mergeInfo, rh, tableKeyCol, tableModuleCol, timeStartCol, cEnd }) {
      const dataRows = [];
      let rEnd = rh;
      let emptyStreak = 0;
      const sheetRange = ws['!ref'] ? XLSX.utils.decode_range(ws['!ref']) : null;
      const maxHeight = Math.min(sheetRange ? sheetRange.e.r : rh + 400, rh + 400);
      const emptyRowLimit = 2;
      for (let r = rh + 1; r <= maxHeight; r += 1) {
        const keyValue = getVisibleValue(ws, grid, mergeInfo, r, tableKeyCol);
        const moduleValue = getVisibleValue(ws, grid, mergeInfo, r, tableModuleCol);
        if (isHeaderRow({ ws, grid, mergeInfo, r, tableKeyCol, tableModuleCol, timeStartCol }) && r > rh + 1) {
          break;
        }
        const valueFill = countRowValues({ ws, grid, mergeInfo, r, timeStartCol, cEnd });
        const isRowEmpty = isEmptyValue(keyValue) && isEmptyValue(moduleValue) && valueFill === 0;

        if (!isRowEmpty) {
          dataRows.push(r);
          rEnd = r;
          emptyStreak = 0;
        } else {
          emptyStreak += 1;
          if (emptyStreak >= emptyRowLimit && dataRows.length) break;
        }
      }
      return { dataRows, rEnd };
    }

    function isHeaderRow({ ws, grid, mergeInfo, r, tableKeyCol, tableModuleCol, timeStartCol }) {
      const keyValue = getVisibleValue(ws, grid, mergeInfo, r, tableKeyCol);
      const moduleValue = getVisibleValue(ws, grid, mergeInfo, r, tableModuleCol);
      const thirdValue = getVisibleValue(ws, grid, mergeInfo, r, timeStartCol);
      return normalizeHeaderText(keyValue) === 'key'
        && normalizeHeaderText(moduleValue) === 'module'
        && !isEmptyValue(thirdValue);
    }

    function countRowValues({ ws, grid, mergeInfo, r, c0, c1 }) {
      let count = 0;
      for (let c = c0; c <= c1; c += 1) {
        const value = getVisibleValue(ws, grid, mergeInfo, r, c);
        if (!isEmptyValue(value)) count += 1;
      }
      return count;
    }

    function resolveMachineName({ ws, grid, mergeInfo, rh, rMeta, tableKeyCol, rEnd }) {
      const machineCol = 0;
      const direct = getVisibleValue(ws, grid, mergeInfo, rh, machineCol);
      if (!isEmptyValue(direct)) return String(direct);

      for (let r = rh - 1; r >= 0; r -= 1) {
        const value = getVisibleValue(ws, grid, mergeInfo, r, machineCol);
        if (!isEmptyValue(value)) return String(value);
      }

      for (let r = rh + 1; r <= rEnd; r += 1) {
        const value = getVisibleValue(ws, grid, mergeInfo, r, machineCol);
        if (!isEmptyValue(value)) return String(value);
      }

      return 'Unknown machine';
    }

    function shouldSkipRowByKeyCell(value) {
      const text = String(value ?? '').trim();
      if (!text) return true;
      if (text.startsWith('*')) return true;
      if (/fte/i.test(text)) return true;
      return false;
    }

    function parseTableRows({
      ws,
      grid,
      mergeInfo,
      rh,
      rEnd,
      tableKeyCol,
      tableModuleCol,
      timeStartCol,
      timeHeaders,
      cEnd,
      sheetName,
      tableId
    }) {
      const rows = [];
      let totalRow = null;

      for (let r = rh + 1; r <= rEnd; r += 1) {
        const key = getVisibleValue(ws, grid, mergeInfo, r, tableKeyCol);
        const module = getVisibleValue(ws, grid, mergeInfo, r, tableModuleCol);
        if (shouldSkipRowByKeyCell(key)) {
          continue;
        }
        const valuesByTime = {};
        let numericCount = 0;

        for (const header of timeHeaders) {
          const timeLabel = header.label;
          let value = getVisibleValue(ws, grid, mergeInfo, r, header.col);
          if (header.extraCols.length) {
            header.extraCols.forEach((extraCol) => {
              const extraValue = getVisibleValue(ws, grid, mergeInfo, r, extraCol);
              if (!isEmptyValue(extraValue)) {
                logEvent('error', `Duplicate time value for "${timeLabel}" in ${tableId} (row ${r}).`, {
                  sheetName,
                  primaryCol: header.col,
                  extraCol,
                  primaryValue: value,
                  extraValue
                });
                value = extraValue;
              }
            });
          }
          const num = parseNumeric(value);
          if (num !== null) numericCount += 1;
          valuesByTime[timeLabel] = num;
        }

        const row = {
          key: key ? String(key) : null,
          module: module ? String(module) : null,
          valuesByTime,
          isTotalRow: false
        };

        const keyText = key ? String(key) : '';
        const looksTotal = /total|sum|totaal/i.test(keyText);
        const fillRatio = timeHeaders.length ? numericCount / timeHeaders.length : 0;
        if (looksTotal || (r === rEnd && fillRatio > 0.6)) {
          row.isTotalRow = true;
          totalRow = row;
        } else if (!isEmptyValue(row.key) || !isEmptyValue(row.module)) {
          rows.push(row);
        }
      }

      return { rows, totalRow };
    }

    function parseNumeric(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;
      if (typeof value === 'string') {
        const cleaned = value.replace(/,/g, '').trim();
        if (cleaned === '') return null;
        const num = Number(cleaned);
        return Number.isNaN(num) ? null : num;
      }
      return null;
    }

    function checkBoundaryIsolation({ ws, grid, mergeInfo, tableRange }) {
      const samples = [];
      const rSamples = [tableRange.r0, tableRange.r1, Math.floor((tableRange.r0 + tableRange.r1) / 2)];
      rSamples.forEach((r) => {
        samples.push({ r, c: tableRange.c1 + 1 });
        samples.push({ r, c: tableRange.c1 + 2 });
        samples.push({ r: tableRange.r1 + 1, c: tableRange.c0 });
      });

      let emptyCount = 0;
      samples.forEach((cell) => {
        const value = getVisibleValue(ws, grid, mergeInfo, cell.r, cell.c);
        if (isEmptyValue(value)) emptyCount += 1;
      });

      const ratio = emptyCount / samples.length;
      return { ratio, isIsolated: ratio >= 0.6 };
    }

    function buildFacts() {
      state.facts = [];
      state.tableRecords.forEach((record) => {
        record.rows.forEach((row) => {
          record.times.forEach((time) => {
            const value = row.valuesByTime[time];
            if (value == null) {
              return;
            }
            state.facts.push({
              department: record.department,
              machine: record.machineName,
              timeframeLabel: record.timeframeLabel,
              unitLabel: record.unitLabel,
              key: row.key,
              module: row.module,
              time,
              value
            });
          });
        });
      });
    }

    function computeSummary() {
      const departments = new Set();
      const machines = new Set();
      const timeframes = new Set();
      const units = new Set();
      state.tableRecords.forEach((record) => {
        departments.add(record.department);
        machines.add(record.machineName);
        timeframes.add(record.timeframeLabel);
        units.add(record.unitLabel);
      });
      state.summary = {
        sheetCount: state.workbook.SheetNames.length,
        targetTables: state.tableRecords.length,
        quarantinedTables: state.nonTargetTables.length,
        departments: Array.from(departments),
        machines: Array.from(machines),
        timeframes: Array.from(timeframes),
        units: Array.from(units)
      };
    }

    function renderAll() {
      renderSummary();
      renderFilters();
      renderTables();
      renderQuarantine();
      renderExpectedShape();
      renderPivotSummary();
      renderLog();
    }

    function renderSummary() {
      const stats = [
        { label: 'Sheets', value: state.summary.sheetCount },
        { label: 'Target tables', value: state.summary.targetTables },
        { label: 'Quarantined', value: state.summary.quarantinedTables },
        { label: 'Departments', value: state.summary.departments.length },
        { label: 'Machines', value: state.summary.machines.length },
        { label: 'Timeframes', value: state.summary.timeframes.length },
        { label: 'Units', value: state.summary.units.length }
      ];
      summaryStats.innerHTML = stats.map((stat) => `
        <div class="stat-card">
          <span class="muted">${stat.label}</span>
          <strong>${stat.value}</strong>
        </div>
      `).join('');
    }

    function renderExpectedShape() {
      const expectedTables = EXPECTED.departments * EXPECTED.machines * EXPECTED.timeframes * EXPECTED.units;
      expectedShape.textContent = `Expected roughly ${EXPECTED.departments} departments Ã— ${EXPECTED.machines} machines Ã— ${EXPECTED.timeframes} timeframes Ã— ${EXPECTED.units} units = ${expectedTables} tables. Detected ${state.tableRecords.length} target tables.`;
    }

    function renderPivotSummary() {
      if (!state.tableRecords.length) {
        pivotSummary.innerHTML = '<p class="muted">Run extraction to see the pivot summary.</p>';
        return;
      }
      const pivot = new Map();
      const ensureMap = (map, key) => {
        if (!map.has(key)) map.set(key, new Map());
        return map.get(key);
      };
      state.tableRecords.forEach((record) => {
        const department = record.department ?? 'Unknown department';
        const machine = record.machineName ?? 'Unknown machine';
        const timeframe = record.timeframeLabel ?? 'Unknown timeframe';
        const unit = record.unitLabel ?? 'Unknown unit';
        const machineMap = ensureMap(pivot, department);
        const timeframeMap = ensureMap(machineMap, machine);
        const unitMap = ensureMap(timeframeMap, timeframe);
        unitMap.set(unit, (unitMap.get(unit) || 0) + 1);
      });

      const sumMap = (map) => {
        let total = 0;
        map.forEach((value) => {
          if (value instanceof Map) {
            total += sumMap(value);
          } else {
            total += value;
          }
        });
        return total;
      };

      const sortEntries = (entries) => {
        return entries.sort((a, b) => {
          const aTotal = a[1] instanceof Map ? sumMap(a[1]) : a[1];
          const bTotal = b[1] instanceof Map ? sumMap(b[1]) : b[1];
          if (bTotal !== aTotal) return bTotal - aTotal;
          return String(a[0]).localeCompare(String(b[0]));
        });
      };

      const renderCount = (count) => `
        <span class="count-badge ${count > 1 ? 'alert' : ''}">${count}</span>
      `;

      const renderUnits = (unitMap) => {
        const units = sortEntries(Array.from(unitMap.entries()));
        return `
          <ul class="pivot-tree">
            ${units.map(([unit, count]) => `
              <li><span class="pivot-subtle">${unit}</span> ${renderCount(count)}</li>
            `).join('')}
          </ul>
        `;
      };

      const renderTimeframes = (timeframeMap) => {
        const timeframes = sortEntries(Array.from(timeframeMap.entries()));
        return `
          <ul class="pivot-tree">
            ${timeframes.map(([timeframe, unitMap]) => `
              <li>
                <span class="pivot-label">${timeframe}</span>
                ${renderUnits(unitMap)}
              </li>
            `).join('')}
          </ul>
        `;
      };

      const renderMachines = (machineMap) => {
        const machines = sortEntries(Array.from(machineMap.entries()));
        return `
          <ul class="pivot-tree">
            ${machines.map(([machine, timeframeMap]) => `
              <li>
                <span class="pivot-label">${machine}</span>
                ${renderTimeframes(timeframeMap)}
              </li>
            `).join('')}
          </ul>
        `;
      };

      const renderDepartments = () => {
        const departments = sortEntries(Array.from(pivot.entries()));
        return departments.map(([department, machineMap]) => `
          <div class="card">
            <h4>${department}</h4>
            ${renderMachines(machineMap)}
          </div>
        `).join('');
      };
      const totalFacts = state.facts.length;
      const totalRows = state.tableRecords.reduce((sum, record) => sum + record.rows.length, 0);
      pivotSummary.innerHTML = `
        <div class="pivot-summary-grid">
          ${renderDepartments()}
        </div>
        <p class="muted small">Totals: ${state.tableRecords.length} tables Â· ${totalRows} data rows Â· ${totalFacts} fact values.</p>
      `;
    }

    function renderFilters() {
      populateFilter(filterDepartment, state.summary.departments);
      populateFilter(filterMachine, state.summary.machines);
      populateFilter(filterTimeframe, state.summary.timeframes);
      populateFilter(filterUnit, state.summary.units);
    }

    function populateFilter(select, values) {
      const previous = select.value || 'All';
      select.innerHTML = '';
      ['All', ...values].forEach((value) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
      });
      select.value = values.includes(previous) ? previous : 'All';
    }

    function filterRecord(record) {
      const { department, machine, timeframe, unit } = state.filters;
      if (department !== 'All' && record.department !== department) return false;
      if (machine !== 'All' && record.machineName !== machine) return false;
      if (timeframe !== 'All' && record.timeframeLabel !== timeframe) return false;
      if (unit !== 'All' && record.unitLabel !== unit) return false;
      return true;
    }

    function renderTables() {
      const filtered = state.tableRecords.filter(filterRecord);
      if (!filtered.length) {
        tableCards.innerHTML = '<p class="muted">No tables match the selected filters.</p>';
        return;
      }
      tableCards.innerHTML = '';
      filtered.forEach((record) => {
        const card = document.createElement('div');
        card.className = 'card';
        const confidence = calculateConfidence(record);
        card.innerHTML = `
          <div class="stack">
            <span class="tag">${record.department}</span>
            <span class="tag">${record.machineName}</span>
            <span class="tag">${record.timeframeLabel}</span>
            <span class="tag">${record.unitLabel}</span>
          </div>
          <h4>Table ${record.id}</h4>
          <p class="muted">${record.rows.length} rows Â· ${record.times.length} time columns</p>
          <div class="stack">
            <span class="pill ${confidence >= 70 ? 'success' : 'warning'}">Confidence ${confidence}%</span>
            ${record.qualityFlags.map((flag) => `<span class="pill warning">${flag}</span>`).join('')}
          </div>
          <div class="linkish" data-id="${record.id}">View details</div>
        `;
        card.querySelector('.linkish').addEventListener('click', () => renderDetail(record));
        tableCards.appendChild(card);
      });
    }

    function calculateConfidence(record) {
      let score = 50;
      if (record.unitLabel && record.timeframeLabel) score += 15;
      if (record.times.length >= 3) score += 10;
      if (record.qualityFlags.includes('Weak boundary isolation')) score -= 10;
      if (record.machineName === 'Unknown machine') score -= 10;
      return Math.max(0, Math.min(100, score));
    }

    function renderQuarantine() {
      if (!state.nonTargetTables.length) {
        quarantineCards.innerHTML = '<p class="muted">No quarantined tables.</p>';
        return;
      }
      quarantineCards.innerHTML = '';
      state.nonTargetTables.forEach((table) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="stack">
            <span class="tag">${table.department}</span>
            <span class="tag">${table.sheetName}</span>
          </div>
          <h4>${table.id}</h4>
          <p class="muted">Reasons: ${table.reasons.join(', ')}</p>
          ${renderPreviewTable(table.preview)}
        `;
        quarantineCards.appendChild(card);
      });
    }

    function getFactsColumns() {
      return [
        { key: 'department', label: 'Department' },
        { key: 'machine', label: 'Machine' },
        { key: 'timeframeLabel', label: 'Timeframe' },
        { key: 'unitLabel', label: 'Unit' },
        { key: 'key', label: 'Key' },
        { key: 'module', label: 'Module' },
        { key: 'time', label: 'Time' },
        { key: 'value', label: 'Value' }
      ];
    }

    function getBaseFilteredFacts() {
      const columns = getFactsColumns();
      const search = state.factsSearch.trim().toLowerCase();
      let rows = state.facts.filter((row) => {
        if (state.filters.department !== 'All' && row.department !== state.filters.department) return false;
        if (state.filters.machine !== 'All' && row.machine !== state.filters.machine) return false;
        if (state.filters.timeframe !== 'All' && row.timeframeLabel !== state.filters.timeframe) return false;
        if (state.filters.unit !== 'All' && row.unitLabel !== state.filters.unit) return false;
        return true;
      });

      if (search) {
        rows = rows.filter((row) => {
          return columns.some((column) => {
            const cell = row[column.key];
            return String(cell ?? '').toLowerCase().includes(search);
          });
        });
      }

      return rows;
    }

    function applyColumnFilters(rows) {
      return rows.filter((row) => {
        return Object.entries(state.factsColumnFilters).every(([key, value]) => {
          if (!value || value === 'All') return true;
          const cell = row[key];
          return String(cell ?? '') === value;
        });
      });
    }

    function getFilteredFacts() {
      let rows = getBaseFilteredFacts();
      rows = applyColumnFilters(rows);

      if (state.factsSort.key) {
        const { key, direction } = state.factsSort;
        const factor = direction === 'asc' ? 1 : -1;
        rows = [...rows].sort((a, b) => {
          const aVal = a[key];
          const bVal = b[key];
          if (aVal == null && bVal == null) return 0;
          if (aVal == null) return 1;
          if (bVal == null) return -1;
          if (typeof aVal === 'number' && typeof bVal === 'number') {
            return (aVal - bVal) * factor;
          }
          if (key === 'time') {
            return compareTimeLabels(aVal, bVal) * factor;
          }
          return String(aVal).localeCompare(String(bVal)) * factor;
        });
      }

      return rows;
    }

    function getFactsFilterOptions(rows, columns) {
      const options = {};
      columns.forEach((column) => {
        const values = new Set();
        rows.forEach((row) => {
          const cell = row[column.key];
          if (cell != null && String(cell).trim() !== '') {
            values.add(String(cell));
          }
        });
        options[column.key] = Array.from(values).sort((a, b) => {
          if (column.key === 'time') {
            return compareTimeLabels(a, b);
          }
          return a.localeCompare(b);
        });
      });
      return options;
    }

    function renderFactsTable() {
      if (!tabFacts.classList.contains('active')) {
        return;
      }
      if (!state.facts.length) {
        factsTableContainer.innerHTML = '<p class="muted">Run extraction to see the facts table.</p>';
        factsRowCount.textContent = '';
        factsPageStatus.textContent = '';
        factsPrev.disabled = true;
        factsNext.disabled = true;
        return;
      }

      const columns = getFactsColumns();
      const baseRows = getBaseFilteredFacts();
      const filterOptions = getFactsFilterOptions(baseRows, columns);
      const rows = getFilteredFacts();
      const totalRows = rows.length;
      const perPage = state.factsPagination.perPage;
      const totalPages = Math.max(1, Math.ceil(totalRows / perPage));
      if (state.factsPagination.page > totalPages) {
        state.factsPagination.page = totalPages;
      }
      const page = state.factsPagination.page;
      const startIndex = (page - 1) * perPage;
      const pageRows = rows.slice(startIndex, startIndex + perPage);
      factsRowCount.textContent = `${pageRows.length} of ${totalRows} row${totalRows === 1 ? '' : 's'} shown`;
      factsPageStatus.textContent = `Page ${page} of ${totalPages}`;
      factsPrev.disabled = page <= 1;
      factsNext.disabled = page >= totalPages;

      const sortIndicator = (key) => {
        if (state.factsSort.key !== key) return '';
        return state.factsSort.direction === 'asc' ? ' â–²' : ' â–¼';
      };

      const escapeHtml = (value) => {
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };

      const tableHtml = `
        <table>
          <colgroup>
            ${columns.map((column) => {
              const width = state.factsColumnWidths[column.key];
              return `<col data-key="${column.key}" style="${width ? `width:${width}px;` : ''}" />`;
            }).join('')}
          </colgroup>
          <thead>
            <tr>
              ${columns.map((column) => {
                const width = state.factsColumnWidths[column.key];
                const style = width ? ` style="width:${width}px;"` : '';
                return `<th data-sort="${column.key}"${style}>${column.label}${sortIndicator(column.key)}<span class="resize-handle" data-resize="${column.key}"></span></th>`;
              }).join('')}
            </tr>
            <tr class="filter-row">
              ${columns.map((column) => {
                const value = state.factsColumnFilters[column.key] || 'All';
                const options = ['All', ...filterOptions[column.key]];
                const optionHtml = options.map((option) => {
                  const selected = option === value ? 'selected' : '';
                  return `<option value="${escapeHtml(option)}" ${selected}>${escapeHtml(option)}</option>`;
                }).join('');
                return `<th><select data-filter="${column.key}">${optionHtml}</select></th>`;
              }).join('')}
            </tr>
          </thead>
          <tbody>
            ${pageRows.map((row) => `
              <tr>
                ${columns.map((column) => `<td>${escapeHtml(row[column.key] ?? '')}</td>`).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;

      factsTableContainer.innerHTML = tableHtml;

      factsTableContainer.querySelectorAll('select[data-filter]').forEach((select) => {
        select.addEventListener('change', (event) => {
          const key = event.target.dataset.filter;
          state.factsColumnFilters[key] = event.target.value || 'All';
          state.factsPagination.page = 1;
          renderFactsTable();
        });
      });

      factsTableContainer.querySelectorAll('th[data-sort]').forEach((header) => {
        header.addEventListener('click', () => {
          const key = header.dataset.sort;
          if (state.factsSort.key === key) {
            state.factsSort.direction = state.factsSort.direction === 'asc' ? 'desc' : 'asc';
          } else {
            state.factsSort.key = key;
            state.factsSort.direction = 'asc';
          }
          renderFactsTable();
        });
      });

      attachColumnResizers();
    }

    function attachColumnResizers() {
      const table = factsTableContainer.querySelector('table');
      if (!table) return;

      const updateColumnWidth = (key, width) => {
        const col = table.querySelector(`col[data-key="${key}"]`);
        if (col) {
          col.style.width = `${width}px`;
        }
        const header = table.querySelector(`th[data-sort="${key}"]`);
        if (header) {
          header.style.width = `${width}px`;
        }
      };

      table.querySelectorAll('.resize-handle').forEach((handle) => {
        handle.addEventListener('mousedown', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const key = handle.dataset.resize;
          const header = table.querySelector(`th[data-sort="${key}"]`);
          const startWidth = header ? header.offsetWidth : 120;
          const startX = event.clientX;
          const minWidth = 80;

          const onMouseMove = (moveEvent) => {
            const delta = moveEvent.clientX - startX;
            const nextWidth = Math.max(minWidth, startWidth + delta);
            state.factsColumnWidths[key] = nextWidth;
            updateColumnWidth(key, nextWidth);
          };

          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    function renderLog() {
      if (!state.extractionLog.length) {
        logSummary.textContent = 'No log entries available.';
        logOutput.textContent = '';
        return;
      }
      const errorCount = state.extractionLog.filter((entry) => entry.includes('[ERROR]')).length;
      logSummary.textContent = `${state.extractionLog.length} log entr${state.extractionLog.length === 1 ? 'y' : 'ies'} Â· ${errorCount} error${errorCount === 1 ? '' : 's'}`;
      logOutput.textContent = state.extractionLog.join('\n');
    }

    function renderDetail(record) {
      detailView.innerHTML = `
        <h4>${record.department} Â· ${record.machineName}</h4>
        <p class="muted">${record.timeframeLabel} Â· ${record.unitLabel}</p>
        <div class="stack">
          <span class="pill">Range r${record.tableRange.r0}:c${record.tableRange.c0} â†’ r${record.tableRange.r1}:c${record.tableRange.c1}</span>
          ${record.qualityFlags.map((flag) => `<span class="pill warning">${flag}</span>`).join('')}
        </div>
        <h5>Preview</h5>
        ${renderPreviewTable(buildPreviewFromRecord(record))}
      `;
    }

    function buildPreviewFromRecord(record) {
      const ws = state.workbook.Sheets[record.sheetName];
      const grid = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: null });
      const mergeInfo = buildMergeLookup(ws['!merges'] || []);
      return buildPreview({
        ws,
        grid,
        mergeInfo,
        r0: record.tableRange.r0,
        c0: record.tableRange.c0,
        r1: Math.min(record.tableRange.r0 + 8, record.tableRange.r1),
        c1: Math.min(record.tableRange.c0 + 8, record.tableRange.c1)
      });
    }

    function buildPreview({ ws, grid, mergeInfo, r0, c0, r1, c1 }) {
      const rows = [];
      for (let r = r0; r <= r1; r += 1) {
        const row = [];
        for (let c = c0; c <= c1; c += 1) {
          row.push(getVisibleValue(ws, grid, mergeInfo, r, c));
        }
        rows.push(row);
      }
      return rows;
    }

    function renderPreviewTable(preview) {
      if (!preview || !preview.length) return '<p class="muted">No preview available.</p>';
      const header = preview[0] || [];
      const body = preview.slice(1);
      return `
        <div class="table-preview zoomable">
          <table>
            <thead>
              <tr>${header.map((cell) => `<th>${cell ?? ''}</th>`).join('')}</tr>
            </thead>
            <tbody>
              ${body.map((row) => `<tr>${row.map((cell) => `<td>${cell ?? ''}</td>`).join('')}</tr>`).join('')}
            </tbody>
          </table>
        </div>
      `;
    }

    function exportFactsWorkbook() {
      const rows = state.facts;
      const columns = getFactsColumns();
      const headers = columns.map((column) => column.key);
      const factsSheet = XLSX.utils.json_to_sheet(rows, { header: headers });
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, factsSheet, 'Facts');
      const output = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
      downloadFile(output, 'facts.xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    }

    function buildMacroModule(records) {
      const sanitizedRecords = records.map((record, index) => ({
        index: index + 1,
        sheetName: record.sheetName,
        range: buildMacroRange(record),
        tableName: `ExtractedTable_${String(index + 1).padStart(3, '0')}`,
        queryName: `Query_ExtractedTable_${String(index + 1).padStart(3, '0')}`
      }));

      const lines = [
        'Option Explicit',
        '',
        "' Generated by the Excel Graphical Table Extractor.",
        "' This macro creates Excel tables for each detected range",
        "' and registers them as Power Query connections.",
        'Sub CreateQueriesFromExtractedTables()',
        '  Dim ws As Worksheet',
        '  Dim tbl As ListObject',
        '  Dim existingTable As ListObject',
        '  Dim queryName As String',
        '  Dim tableName As String',
        '  Dim tableRange As Range',
        '  Dim overlapFound As Boolean',
        '  Dim overlapCount As Long',
        '',
        '  Application.ScreenUpdating = False',
        '  Application.DisplayAlerts = False',
        ''
      ];

      if (!sanitizedRecords.length) {
        lines.push('  MsgBox "No tables detected. Run the extractor first.", vbExclamation');
      } else {
        sanitizedRecords.forEach((record) => {
          lines.push(
            `  Set ws = ThisWorkbook.Worksheets("${escapeVbaString(record.sheetName)}")`,
            '  ws.Activate',
            `  tableName = "${record.tableName}"`,
            `  queryName = "${record.queryName}"`,
            `  Set tableRange = ws.Range("${record.range}")`,
            '  On Error Resume Next',
            '  ws.ListObjects(tableName).Delete',
            '  ThisWorkbook.Queries(queryName).Delete',
            '  On Error GoTo 0',
            '  overlapFound = False',
            '  For Each existingTable In ws.ListObjects',
            '    If Not Intersect(existingTable.Range, tableRange) Is Nothing Then',
            '      overlapFound = True',
            '      Exit For',
            '    End If',
            '  Next existingTable',
            '  If overlapFound Then',
            '    overlapCount = overlapCount + 1',
            '  Else',
            '    Set tbl = ws.ListObjects.Add(xlSrcRange, tableRange, , xlYes)',
            '    tbl.Name = tableName',
            '    ThisWorkbook.Queries.Add Name:=queryName, Formula:="let Source = Excel.CurrentWorkbook(){[Name=""" & tableName & """]}[Content] in Source"',
            '  End If',
            ''
          );
        });
        lines.push(
          '  If overlapCount > 0 Then',
          '    MsgBox "Power Query connections created. " & overlapCount & " table(s) skipped due to overlapping ranges.", vbExclamation',
          '  Else',
          '    MsgBox "Power Query connections created for all detected tables.", vbInformation',
          '  End If'
        );
      }

      lines.push(
        '',
        '  Application.DisplayAlerts = True',
        '  Application.ScreenUpdating = True',
        'End Sub',
        ''
      );

      return lines.join('\n');
    }

    function buildMacroRange(record) {
      return XLSX.utils.encode_range({
        s: { r: record.headerRow, c: record.tableRange.c0 },
        e: { r: record.tableRange.r1, c: record.tableRange.c1 }
      });
    }

    function escapeVbaString(value) {
      return String(value).replace(/"/g, '""');
    }

    function toCsv(rows, columns = null) {
      if (!rows.length) return '';
      const headers = columns ? columns.map((column) => column.key) : Object.keys(rows[0]);
      const escapeCell = (value) => {
        if (value == null) return '';
        const text = String(value).replace(/"/g, '""');
        if (/[,\n"]/.test(text)) return `"${text}"`;
        return text;
      };
      const csvRows = [headers.join(',')];
      rows.forEach((row) => {
        csvRows.push(headers.map((header) => escapeCell(row[header])).join(','));
      });
      return csvRows.join('\n');
    }

    function downloadFile(content, filename, type) {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
